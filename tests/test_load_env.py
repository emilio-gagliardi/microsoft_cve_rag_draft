# Generated by CodiumAI
from microsoft_cve_support_rag.app_utils import load_env
import pytest
import os
from dotenv import load_dotenv


class TestLoadEnv:
    @pytest.fixture(autouse=True)
    def setup_env(self):
        # Set up any necessary environment variables or state
        os.environ["ENVIRONMENT"] = "local"

    # Environment variable 'ENVIRONMENT' is set and maps to a valid .env file
    def test_env_var_set_maps_to_valid_env_file(self, mocker):
        # Arrange
        mocker.patch("os.getenv", return_value="docker")
        mocker.patch(
            "os.path.dirname",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag",
        )
        mocker.patch(
            "os.path.abspath",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/microsoft_cve_support_rag/app_utils.py",
        )
        mocker.patch(
            "os.path.join",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/.env.docker",
        )
        mock_load_dotenv = mocker.patch(
            "microsoft_cve_support_rag.app_utils.load_dotenv", return_value=True
        )

        # Act
        load_env()

        # Assert
        mock_load_dotenv.assert_called_once_with(
            "C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/.env.docker"
        )

        # Additional assertions to verify the behavior
        assert os.getenv("ENVIRONMENT") == "docker"
        print(f"Mock load_dotenv called with: {mock_load_dotenv.call_args}")

    # Environment variable 'ENVIRONMENT' is set to an invalid value not in the map
    def test_env_var_set_to_invalid_value(self, mocker):
        # Arrange
        mocker.patch("os.getenv", return_value="invalid")
        mocker.patch(
            "os.path.dirname",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag",
        )
        mocker.patch(
            "os.path.abspath",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/microsoft_cve_support_rag/app_utils.py",
        )
        mocker.patch(
            "os.path.join",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/.env.local",
        )
        mock_load_dotenv = mocker.patch(
            "microsoft_cve_support_rag.app_utils.load_dotenv", return_value=True
        )

        # Act
        load_env()

        # Assert
        mock_load_dotenv.assert_called_once_with(
            "C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/.env.local"
        )

        # Additional assertions to verify the behavior
        assert os.getenv("ENVIRONMENT") == "invalid"
        print(f"Mock load_dotenv called with: {mock_load_dotenv.call_args}")

    # The .env file specified in the map does not exist
    def test_env_file_does_not_exist(self, mocker):
        # Arrange
        mocker.patch("os.getenv", return_value="docker")
        mocker.patch(
            "os.path.dirname",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag",
        )
        mocker.patch(
            "os.path.abspath",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/microsoft_cve_support_rag/app_utils.py",
        )
        mocker.patch(
            "os.path.join",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/.env.nonexistent",
        )
        mocker.patch("os.path.exists", return_value=False)
        mock_load_dotenv = mocker.patch(
            "microsoft_cve_support_rag.app_utils.load_dotenv", return_value=True
        )

        # Act & Assert
        with pytest.raises(
            FileNotFoundError,
            match="The .env file at path C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/.env.nonexistent does not exist.",
        ):
            load_env()

        # Ensure load_dotenv is not called
        mock_load_dotenv.assert_not_called()

    def test_load_env_success(self, mocker):
        # Arrange
        mocker.patch(
            "os.getenv",
            side_effect=lambda key, default=None: {
                "ENVIRONMENT": "local",
                "OPENAI_API_KEY": "dummy_openai_key",
                "EXA_API_KEY": "dummy_exa_key",
                "SERPER_API_KEY": "dummy_serper_key",
            }.get(key, default),
        )
        mocker.patch(
            "os.path.dirname",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag",
        )
        mocker.patch(
            "os.path.abspath",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/microsoft_cve_support_rag/app_utils.py",
        )
        mocker.patch(
            "os.path.join",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/.env.local",
        )
        mocker.patch("os.path.exists", return_value=True)
        mock_load_dotenv = mocker.patch(
            "microsoft_cve_support_rag.app_utils.load_dotenv", return_value=True
        )

        # Act
        load_env()

        # Assert
        assert os.getenv("OPENAI_API_KEY") == "dummy_openai_key"
        assert os.getenv("EXA_API_KEY") == "dummy_exa_key"
        assert os.getenv("SERPER_API_KEY") == "dummy_serper_key"
        print(f"Mock load_dotenv called with: {mock_load_dotenv.call_args}")

    def test_load_env_failure(self, mocker):
        # Arrange
        mocker.patch(
            "os.getenv",
            side_effect=lambda key, default=None: {
                "ENVIRONMENT": "local",
                "EXA_API_KEY": "dummy_exa_key",
                "SERPER_API_KEY": "dummy_serper_key",
            }.get(key, default),
        )  # OPENAI_API_KEY is intentionally missing
        mocker.patch(
            "os.path.dirname",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag",
        )
        mocker.patch(
            "os.path.abspath",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/microsoft_cve_support_rag/app_utils.py",
        )
        mocker.patch(
            "os.path.join",
            return_value="C:/Users/emili/PycharmProjects/microsoft_cve_support_rag/.env.local",
        )
        mocker.patch("os.path.exists", return_value=True)
        mock_load_dotenv = mocker.patch(
            "microsoft_cve_support_rag.app_utils.load_dotenv", return_value=True
        )

        # Act
        load_env()

        # Assert
        assert os.getenv("OPENAI_API_KEY") is None
        print(f"Mock load_dotenv called with: {mock_load_dotenv.call_args}")
